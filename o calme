
external or': bool -> bool -> bool = "%sequor"
external and': bool -> bool -> bool = "%sequand"


let rec ack m n = match (m, n) with
  | (0, n) -> n + 1
  | (m, 0) -> if m > 0 then ack (m - 1) 1 else failwith "m should be greater than 0" 
  | (m, n) -> if m > 0 && n > 0 then ack (m - 1) (ack m (n - 1)) else failwith "m and n should be greater than 0" 

let rec mem x l = match l with 
  | [] -> false
  | hd :: tl -> or' (x = hd) (mem x tl)
    

let list_min l = 
  let rec list_min_rec l mini = match l with
    | [] -> mini
    | hd :: tl -> list_min_rec tl (if hd < mini then hd else mini)
  in match l with 
  | [] -> failwith "try to fidn a minimal item in an empty list"
  | hd :: tl -> list_min_rec tl hd
        
(* On fait le choit ici de ne pas privilÃ©gier la recurtion terminal au profit 
d'une Ã©valuation paresseuse de la list *)          
let rec is_sorted l = match l with
  | [] -> true
  | [ _ ] -> true
  | x :: x' :: tl -> and' (x <= x') (is_sorted (x' :: tl))
                       
let average l = 
  let rec average_rec l acc len = match l with
    | [] -> acc / len
    | hd :: tl -> average_rec tl (acc + hd) (len + 1)
  in match l with 
  | [] -> failwith "try to calcul the mean of an empty list"
  | _  -> average_rec l 0 0

let rec nth l k = 
  let rec nth_rec l k idx = match l with
    | [] -> failwith "k is greater than the len of the list"
    | hd :: tl -> if k = idx then hd else nth_rec tl k (idx + 1)
  in nth_rec l k 0
    
                                       
type ordering = Greater | Equal | Less  
let cmp x y = if x > y
  then Greater
  else if x = y 
  then Equal
  else Less

let range m n = 
  let rec range_rec m n l = match cmp m n with
    | Greater -> range_rec m (n + 1) (n :: l)
    | Equal -> n :: l
    | Less ->range_rec m (n - 1) (n :: l)
  in range_rec m n []
    
let _ = range 6 3 


------------------------------------------------------------------------

let rec map f l = match l with 
  | [] -> []
  | hd :: tl -> f hd :: map f tl
                  
let rec filter f l = match l with 
  | [] -> []
  | hd :: tl -> if f hd then hd :: filter f tl else filter f tl
          
let rec rev l = 
  let rec rev_rec l l' = 
    match l with
    | [] -> l'
    | hd :: tl -> rev_rec tl (hd :: l')
  in rev_rec l []
    
