
external or': bool -> bool -> bool = "%sequor"
external and': bool -> bool -> bool = "%sequand"


let rec ack m n = match (m, n) with
  | (0, n) -> n + 1
  | (m, 0) -> if m > 0 then ack (m - 1) 1 else failwith "m should be greater than 0" 
  | (m, n) -> if m > 0 && n > 0 then ack (m - 1) (ack m (n - 1)) else failwith "m and n should be greater than 0" 

let rec mem x l = match l with 
  | [] -> false
  | hd :: tl -> or' (x = hd) (mem x tl)
    

let list_min l = 
  let rec list_min_rec l mini = match l with
    | [] -> mini
    | hd :: tl -> list_min_rec tl (if hd < mini then hd else mini)
  in match l with 
  | [] -> failwith "try to fidn a minimal item in an empty list"
  | hd :: tl -> list_min_rec tl hd
        
(* On fait le choit ici de ne pas privilégier la recurtion terminal au profit 
d'une évaluation paresseuse de la list *)          
let rec is_sorted l = match l with
  | [] -> true
  | [ _ ] -> true
  | x :: x' :: tl -> and' (x <= x') (is_sorted (x' :: tl))
                       
let average l = 
  let rec average_rec l acc len = match l with
    | [] -> acc / len
    | hd :: tl -> average_rec tl (acc + hd) (len + 1)
  in match l with 
  | [] -> failwith "try to calcul the mean of an empty list"
  | _  -> average_rec l 0 0

let rec nth l k = 
  let rec nth_rec l k idx = match l with
    | [] -> failwith "k is greater than the len of the list"
    | hd :: tl -> if k = idx then hd else nth_rec tl k (idx + 1)
  in nth_rec l k 0
    
